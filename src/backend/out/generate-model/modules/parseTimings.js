import { spawnSync } from 'child_process';
import readline from 'readline';
import fs from 'fs-extra';
import path from 'path';
export default async function parseTimings(test, profile) {
    if ((test.enabled && test.unitToTest === 'parseTimings') || !test.enabled) {
        /**
         * ? __dirname Variable
         * * Used to get the current directory of the app
         */
        const currentModuleUrl = new URL(import.meta.url);
        const __dirname = path.dirname(currentModuleUrl.pathname + '../').slice(1);
        const uniqueID = Date.now();
        const corpusDirectory = path.join(__dirname, '../../../files/generate-model/temporary', `${uniqueID}`);
        const dictionaryPath = path.join(__dirname, '../../../files/generate-model/permanent/', 'english_us_arpa.dict');
        const acousticModelPath = path.join(__dirname, '../../../files/generate-model/permanent/english_us_arpa');
        const outputDir = path.join(__dirname, '../../../files/generate-model/temporary/transcript');
        // * Delete the corpus directory if it exists
        if (fs.existsSync(corpusDirectory)) {
            fs.rmdirSync(corpusDirectory, { recursive: true });
        }
        // * Create the corpus directory
        fs.mkdirSync(corpusDirectory, { recursive: true });
        // * Delete the output directory if it exists
        if (fs.existsSync(outputDir)) {
            fs.rmdirSync(outputDir, { recursive: true });
        }
        // * Create the output directory
        fs.mkdirSync(outputDir, { recursive: true });
        // Convert MP3 to WAV
        const audioPath = path.join(__dirname, '../../../files/generate-model/temporary/subtitles.mp3');
        const wavAudioPath = path.join(corpusDirectory, 'audio.wav');
        const ffmpeg = spawnSync('ffmpeg', ['-i', audioPath, wavAudioPath]);
        if (ffmpeg.error) {
            console.log('An error occurred: ' + ffmpeg.error.message);
            await parseTimings(test, profile);
            return;
        }
        // * Prepare Transcript File
        const videoScriptJSON = JSON.parse(fs.readFileSync(path.join(__dirname, '../../../files/generate-model/permanent/prompt.json'), 'utf-8'));
        fs.writeFileSync(path.join(corpusDirectory, 'audio.lab'), '');
        for (const key in videoScriptJSON) {
            const video = videoScriptJSON[key];
            fs.appendFileSync(path.join(corpusDirectory, 'audio.lab'), video.message + '\n');
        }
        // * Start MFA
        const process = spawnSync('mfa', ['align', '--single_speaker', '--num_jobs', `${profile.settings.advanced.cpuCores}`, corpusDirectory, dictionaryPath, acousticModelPath, outputDir]);
        console.log(process.stderr ? process.stderr.toString() : '');
        console.log(process.stdout ? process.stdout.toString() : '');
        // * Restart the function if the texgrid file does not exist
        if (!fs.existsSync(path.join(outputDir, 'audio.TextGrid'))) {
            await parseTimings(test, profile);
            return;
        }
        // * Delete the corpus directory
        fs.rmdirSync(corpusDirectory, { recursive: true });
        return parseTextGrid(path.join(outputDir, 'audio.TextGrid'));
    }
}
/**
 * @param textGridPath The path to the TextGrid file.
 * @returns An array of items.
 * Used in this specific case, to parse the TextGrid file generated by MFA
 */
async function parseTextGrid(filePath) {
    const fileStream = fs.createReadStream(filePath);
    const rl = readline.createInterface({
        input: fileStream,
        crlfDelay: Infinity
    });
    let itemIndex = 0;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const intervals = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let currentInterval = {};
    for await (const line of rl) {
        if (line.includes('item [1]:')) {
            itemIndex = 1;
        }
        else if (line.includes('item [2]:')) {
            itemIndex = 2;
        }
        if (itemIndex === 1) {
            // Parse the lines for item [1]
            if (line.includes('intervals')) {
                if (Object.keys(currentInterval).length > 0 && 'text' in currentInterval) {
                    intervals.push(currentInterval);
                }
                currentInterval = {};
            }
            else {
                const match = line.match(/(\w+) = (.+)/);
                if (match) {
                    const key = match[1];
                    const value = match[2].replace(/"/g, '');
                    currentInterval[key] = value;
                }
            }
        }
    }
    // Push the last interval
    if (Object.keys(currentInterval).length > 0 && 'text' in currentInterval) {
        intervals.push(currentInterval);
    }
    return intervals;
}
